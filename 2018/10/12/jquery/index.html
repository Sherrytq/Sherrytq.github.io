<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Jquery | 搓搓の博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Jquery</h1><a id="logo" href="/.">搓搓の博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Jquery</h1><div class="post-meta">Oct 12, 2018<span> | </span><span class="category"><a href="/categories/前端/">前端</a></span></div><div class="post-content"><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>这里需要注意 jQuery 分 2 个系列版本 1.x 与 2.x，主要的区别在于 2.x 不再兼容 IE6、7、8浏览器，这样做的目的是为了兼容移动端开发。</p>
<p>抛开jQuery，如果要获取文档中所有的元素，通过document.getElementsByTagName()中传递”*”同样可以获取到</p>
<p>不难发现，id、class、tag都可以通过原生的方法获取到对应的节点，但是我们还需要考虑一个兼容性的问题，我这里顺便提及一下，比如:</p>
<p>IE会将注释节点实现为元素，所以在IE中调用getElementsByTagName里面会包含注释节点，这个通常是不应该的<br>getElementById的参数在IE8及较低的版本不区分大小写<br>IE7及较低的版本中，表单元素中，如果表单A的name属性名用了另一个元素B的ID名并且A在B之前，那么getElementById会选中A<br>IE8及较低的版本，浏览器不支持getElementsByClassName</p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p><img src="https://i.imgur.com/F2ojRUv.png" alt="层级选择器"></p>
<p><img src="https://i.imgur.com/XqL9Uqf.png" alt="筛选选择器"></p>
<ul>
<li>注意事项：<br>:eq(), :lt(), :gt(), :even, :odd 用来筛选他们前面的匹配表达式的集合元素，根据之前匹配的元素在进一步筛选，注意jQuery合集都是从0开始索引<br>gt是一个段落筛选，从指定索引的下一个开始，gt(1) 实际从2开始<br><img src="https://i.imgur.com/bzCHRXJ.png" alt="内容筛选选择器"></li>
<li><p>注意事项：<br>:contains与:has都有查找的意思，但是contains查找包含“指定文本”的元素，has查找包含“指定元素”的元素<br>如果:contains匹配的文本包含在元素的子元素中，同样认为是符合条件的。<br>:parent与:empty是相反的，两者所涉及的子元素，包括文本节点<br><img src="https://i.imgur.com/8nDN5wV.png" alt="可见性筛选选择器"></p>
</li>
<li><p>我们有几种方式可以隐藏一个元素：<br>CSS display的值是none。<br>type=”hidden”的表单元素。<br>宽度和高度都显式设置为0。<br>一个祖先元素是隐藏的，该元素是不会在页面上显示<br>CSS visibility的值是hidden<br>CSS opacity的指是0</p>
</li>
</ul>
<p><img src="https://i.imgur.com/w8cC8fD.png" alt="属性筛选选择器"></p>
<p><img src="https://i.imgur.com/YHtUz5u.png" alt="子元素筛选选择器"><br>注意事项：</p>
<p>:first只匹配一个单独的元素，但是:first-child选择器可以匹配多个：即为每个父级元素匹配第一个子元素。这相当于:nth-child(1)<br>:last 只匹配一个单独的元素， :last-child 选择器可以匹配多个元素：即，为每个父级元素匹配最后一个子元素<br>如果子元素只有一个的话，:first-child与:last-child是同一个<br> :only-child匹配某个元素是父元素中唯一的子元素，就是说当前子元素是父元素中唯一的元素，则匹配<br>jQuery实现:nth-child(n)是严格来自CSS规范，所以n值是“索引”，也就是说，从1开始计数，:nth-child(index)从1开始的，而eq(index)是从0开始的<br>nth-child(n) 与 :nth-last-child(n) 的区别前者是从前往后计算，后者从后往前计算</p>
<p><img src="https://i.imgur.com/OTW5asM.png" alt="表单元素选择器"></p>
<h3 id="jq-中的-this"><a href="#jq-中的-this" class="headerlink" title="jq 中的 this"></a>jq 中的 <code>this</code></h3><p><code>this</code>，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。<br><code>$(this)</code>,代表的上下文对象是一个jquery的上下文对象，可以调用jQuery的方法和属性值。</p>
<h3 id="html-text-和-val-的差异总结："><a href="#html-text-和-val-的差异总结：" class="headerlink" title=".html(),.text()和.val()的差异总结："></a>.html(),.text()和.val()的差异总结：</h3><ul>
<li>.html(),.text(),.val()三种方法都是用来读取选定元素的内容；只不过.html()是用来读取元素的html内容（包括html标签），.text()用来读取元素的纯文本内容，包括其后代元素，.val()是用来读取表单元素的”value”值。其中.html()和.text()方法不能使用在表单元素上,而.val()只能使用在表单元素上；另外.html()方法使用在多个元素上时，只读取第一个元素；.val()方法和.html()相同，如果其应用在多个元素上时，只能读取第一个表单元素的”value”值，但是.text()和他们不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容。</li>
<li>.html(htmlString),.text(textString)和.val(value)三种方法都是用来替换选中元素的内容，如果三个方法同时运用在多个元素上时，那么将会替换所有选中元素的内容。</li>
<li>.html(),.text(),.val()都可以使用回调函数的返回值来动态的改变多个元素的内容。</li>
</ul>
<h3 id="jQuery的属性与样式之-css-与-addClass-设置样式的区别"><a href="#jQuery的属性与样式之-css-与-addClass-设置样式的区别" class="headerlink" title="jQuery的属性与样式之.css()与.addClass()设置样式的区别"></a>jQuery的属性与样式之.css()与.addClass()设置样式的区别</h3><p>对于样式的设置，我们学了addClass与css方法，那么两者之间有什么区别？</p>
<p>可维护性：</p>
<p>.addClass()的本质是通过定义个class类的样式规则，给元素添加一个或多个类。css方法是通过JavaScript大量代码进行改变元素的样式</p>
<p>通过.addClass()我们可以批量的给相同的元素设置统一规则，变动起来比较方便，可以统一修改删除。如果通过.css()方法就需要指定每一个元素是一一的修改，日后维护也要一一的修改，比较麻烦</p>
<p>灵活性：</p>
<p>通过.css()方式可以很容易动态的去改变一个样式的属性，不需要在去繁琐的定义个class类的规则。一般来说在不确定开始布局规则，通过动态生成的HTML代码结构中，都是通过.css()方法处理的</p>
<p>样式值：</p>
<p>.addClass()本质只是针对class的类的增加删除，不能获取到指定样式的属性的值，.css()可以获取到指定的样式值。</p>
<p>样式的优先级：</p>
<p>css的样式是有优先级的，当外部样式、内部样式和内联样式同一样式规则同时应用于同一个元素的时候，优先级如下</p>
<p>外部样式 &lt; 内部样式 &lt; 内联样式<br>.addClass()方法是通过增加class名的方式，那么这个样式是在外部文件或者内部样式中先定义好的，等到需要的时候在附加到元素上<br>通过.css()方法处理的是内联样式，直接通过元素的style属性附加到元素上的<br>通过.css方法设置的样式属性优先级要高于.addClass方法<br>总结：</p>
<p>.addClass与.css方法各有利弊，一般是静态的结构，都确定了布局的规则，可以用addClass的方法，增加统一的类规则<br>如果是动态的HTML结构，在不确定规则，或者经常变化的情况下，一般多考虑.css()方式</p>
<h3 id="DOM节点删除之empty和remove区别"><a href="#DOM节点删除之empty和remove区别" class="headerlink" title="DOM节点删除之empty和remove区别"></a>DOM节点删除之empty和remove区别</h3><p>要用到移除指定元素的时候，jQuery提供了empty()与remove([expr])二个方法，两个都是删除元素，但是两者还是有区别</p>
<p>empty方法</p>
<p>严格地讲，empty()方法并不是删除节点，而是清空节点，它能清空元素中的所有后代节点<br>empty不能删除自己本身这个节点<br>remove方法</p>
<p>该节点与该节点所包含的所有后代节点将同时被删除<br>提供传递一个筛选的表达式，删除指定合集中的元素</p>
<h3 id="DOM节点删除之detach-和remove-区别"><a href="#DOM节点删除之detach-和remove-区别" class="headerlink" title="DOM节点删除之detach()和remove()区别"></a>DOM节点删除之detach()和remove()区别</h3><p>JQuery是一个很大强的工具库，在工作开发中，有些方法因为不常用到，或是没有注意到而被我们忽略。</p>
<p>remove()和detach()可能就是其中的一个，可能remove()我们用得比较多，而detach()就可能会很少了</p>
<p> 通过一张对比表来解释2个方法之间的不同<br><img src="https://i.imgur.com/STH7sr4.png" alt=""></p>
<p>remove：移除节点</p>
<p>无参数，移除自身整个节点以及该节点的内部的所有节点，包括节点上事件与数据<br>有参数，移除筛选出的节点以及该节点的内部的所有节点，包括节点上事件与数据<br>detach：移除节点</p>
<p>移除的处理与remove一致<br>与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来<br>例如：$(“p”).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。<br>具体可以参考右边的代码区域的对比</p>
<h3 id="parents-和-closest-是有点相似的，都是往上遍历祖辈元素，但是两者还是有区别的，否则就没有存在的意义了"><a href="#parents-和-closest-是有点相似的，都是往上遍历祖辈元素，但是两者还是有区别的，否则就没有存在的意义了" class="headerlink" title=".parents()和.closest()是有点相似的，都是往上遍历祖辈元素，但是两者还是有区别的，否则就没有存在的意义了"></a>.parents()和.closest()是有点相似的，都是往上遍历祖辈元素，但是两者还是有区别的，否则就没有存在的意义了</h3><p>起始位置不同：.closest开始于当前元素 .parents开始于父元素<br>遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合<br>结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象</p>
<h3 id="mouseenter事件和mouseover的区别"><a href="#mouseenter事件和mouseover的区别" class="headerlink" title="mouseenter事件和mouseover的区别"></a>mouseenter事件和mouseover的区别</h3><p>关键点就是：冒泡的方式处理问题<br>简单的例子：</p>
<p>mouseover为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;aaron2&quot;&gt;</span><br><span class="line">    &lt;p&gt;鼠标离开此区域触发mouseleave事件&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果在p元素与div元素都绑定mouseover事件，鼠标在离开p元素，但是没有离开div元素的时候，触发的结果:</p>
<p>p元素响应事件<br>div元素响应事件<br>这里的问题是div为什么会被触发？ 原因就是事件冒泡的问题，p元素触发了mouseover，他会一直往上找父元素上的mouseover事件，如果父元素有mouseover事件就会被触发</p>
<p>所以在这种情况下面，jQuery推荐我们使用 mouseenter事件</p>
<p>mouseenter事件只会在绑定它的元素上被调用，而不会在后代节点上被触发</p>
<p>这就是最本质的区别，具体的对应可以参考右边的案例：</p>
<h3 id="trigger触发浏览器事件与自定义事件区别？"><a href="#trigger触发浏览器事件与自定义事件区别？" class="headerlink" title="trigger触发浏览器事件与自定义事件区别？"></a>trigger触发浏览器事件与自定义事件区别？</h3><p>自定义事件对象，是jQuery模拟原生实现的<br>自定义事件可以传递参数</p>
<p>triggerHandler与trigger的用法是一样的，重点看不同之处：</p>
<p>triggerHandler不会触发浏览器的默认行为，.triggerHandler( “submit” )将不会调用表单上的.submit()<br>.trigger() 会影响所有与 jQuery 对象相匹配的元素，而 .triggerHandler() 仅影响第一个匹配到的元素<br>使用 .triggerHandler() 触发的事件，并不会在 DOM 树中向上冒泡。 如果它们不是由目标元素直接触发的，那么它就不会进行任何处理<br>与普通的方法返回 jQuery 对象(这样就能够使用链式用法)相反，.triggerHandler() 返回最后一个处理的事件的返回值。如果没有触发任何事件，会返回 undefined</p>
<h3 id="添加函数"><a href="#添加函数" class="headerlink" title="添加函数"></a>添加函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">    $.fn.extend(&#123;</span><br><span class="line">        <span class="string">'focusColor'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newColor</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> oldColor = $(<span class="keyword">this</span>).css(<span class="string">'background-color'</span>);</span><br><span class="line">            $(<span class="keyword">this</span>).hover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                $(<span class="keyword">this</span>).css(...)</span><br><span class="line">                            &#125;,</span><br><span class="line">                            <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    $(<span class="keyword">this</span>).css(..)</span><br><span class="line">                &#125;</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">return</span> $(<span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">                          &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;)(jquery)</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/js/">js</a><a href="/tags/jquery/">jquery</a></div><div class="post-nav"><a class="pre" href="/2018/10/12/handlebars/">Handlebars</a><a class="next" href="/2018/10/12/blog/">Hexo + github 搭建个人博客</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/其他技术/">其他技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/碎碎念/">碎碎念</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/话剧/">话剧</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/前端工具/" style="font-size: 15px;">前端工具</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/jquery/" style="font-size: 15px;">jquery</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/Handlebars/" style="font-size: 15px;">Handlebars</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/响应式/" style="font-size: 15px;">响应式</a> <a href="/tags/区块链/" style="font-size: 15px;">区块链</a> <a href="/tags/BFC/" style="font-size: 15px;">BFC</a> <a href="/tags/盒模型/" style="font-size: 15px;">盒模型</a> <a href="/tags/移动端/" style="font-size: 15px;">移动端</a> <a href="/tags/项目复盘/" style="font-size: 15px;">项目复盘</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/娱乐/" style="font-size: 15px;">娱乐</a> <a href="/tags/跨域/" style="font-size: 15px;">跨域</a> <a href="/tags/话剧/" style="font-size: 15px;">话剧</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/页面布局/">页面布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/30/Promise/">Promise</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/25/滚动优化/">移动端图片滚动优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/前端乱炖_02/">前端乱炖_02</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/区块链/">区块链</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/复盘/">复盘</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/17/webpack/">webpack</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/16/跨域/">跨域</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/15/前端乱炖/">前端乱炖_01</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/15/响应式开发/">响应式</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">搓搓の博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>